'use strict'
const fs = require('fs')
const Promise = require('bluebird')
const Mustache = require('mustache')
const path = require('path')
const cookie = require('cookie') // https://www.npmjs.com/package/cookie
const sessions = require('client-sessions')
const decode = require('urldecode')

/* IMPORTANT: the state of these variables are maintained in between multiple requests so if you need to "reset" after
	sending back a response, make sure to do so (see setVertexSession() - shouldClearSession is reset to false) */
const SESSION_COOKIE_NAME = 'vertexSession'
let shouldClearSession = false

// object observer for vertexSession:
const proxyVertexSession = function(vertexSession, req){ // http://blog.revathskumar.com/2016/02/es6-observe-change-in-object-using-proxy.html
	const handler = {
		set: function(target, key, value){
			if (target != vertexSession)
				return

			req.vertexSessionChanged = true
			target[key] = value
		}
	}

	return new Proxy(vertexSession, handler)
}

const readFile = function(filePath){
	return new Promise(function(resolve, reject){
		fs.readFile(filePath, 'utf8', function(err, file){
			if (err){
				reject(new Error('File Not Found: ' + filePath))
				return
			}

			resolve(file)
		})
	})
}

const readDirectory = function(directory){
	return new Promise(function(resolve, reject){
		fs.readdir(directory, function(err, files){
			if (err){
				reject(err)
				return
			}

			resolve(files)
		})
	})
}

const renderMustache = function(pkg){
	return new Promise(function(resolve, reject){
		var template = pkg.template
		if (template == null){
			reject(new Error('Missing template'))
			return
		}

		var data = pkg.data
		if (data == null){
			reject(new Error('Missing data'))
			return
		}

		var partials = pkg.partials || {} // can be null

		try {
			var props = data || {} // have to insert something here otherwise it crashes Mustache.render()
			var html = Mustache.render(template, props, partials)
			resolve(html)
		}
		catch(err) {
			reject(err)
		}
	})
}

const getCookieName = function(opts){
	let cookieName = SESSION_COOKIE_NAME
	if (opts != null){
		if (opts.session != null){
			cookieName = opts.session.cookieName || SESSION_COOKIE_NAME
		}
	}

	return cookieName
}

const setVertexSession = function(req, headers, opts){ // opts can be null
	let cookieName = getCookieName(opts)
	if (shouldClearSession == true){ // clear session:
		// https://stackoverflow.com/questions/5285940/correct-way-to-delete-cookies-server-side
		// headers['Set-Cookie'] = SESSION_COOKIE_NAME+'=deleted; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT'
		headers['Set-Cookie'] = cookieName+'=deleted; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT'
		shouldClearSession = false
		return headers
	}

	if (req.vertexSessionChanged == false) // no change to session, don't reset cookie
		return headers

	// var vertexSession = req.vertexSession || {} // just in case
	var vertexSession = req[cookieName] || {} // just in case

	delete vertexSession['reset'] // remove this because it's not set by the user
	if (Object.keys(vertexSession).length == 0) // nothing changed in session - don't do anything.
		return headers

	// headers['Set-Cookie'] = 'vertexSession=' + sessionToken + '; HttpOnly; Path=/'
	// this comes back in the req.headers.Cookie object like so: "vertexSession={\"user\":{\"id\":\"123123\",\"username\":\"danpatrick\"}}"

	var sessionToken = JSON.stringify(vertexSession)
	// var encoded = sessions.util.encode({cookieName:SESSION_COOKIE_NAME, secret:'abc'}, sessionToken, null, null)
	// headers['Set-Cookie'] = SESSION_COOKIE_NAME+'='+encoded+'; path=/;' // always set to base path

	var encoded = sessions.util.encode({cookieName:cookieName, secret:'abc'}, sessionToken, null, null)
	headers['Set-Cookie'] = cookieName+'='+encoded+'; path=/;' // always set to base path
	return headers
}

const configureResponse = function(req, callback, opts){ // opts can be null
	let viewsDir = 'views'
	if (opts != null)
		viewsDir = opts.views || 'views'

	var res = {
		statusCode: 200,
		setHeader: function(key, value){
			var headers = {}
			headers[key] = value
		},

		json: function(data){
			var headers = {'Content-Type': 'application/json'}
			callback(null, {
				isBase64Encoded: false,
				statusCode: 200,
				// headers: setVertexSession(req, headers, opts),
				headers: headers,
				body: JSON.stringify(data)
			})
		},

		data: function(data){
			data['req'] = req
			callback(null, {
				isBase64Encoded: false,
				statusCode: 200,
				headers: {'Content-Type': 'application/json'},
				body: JSON.stringify(data)
			})
		},

		send: function(text){
			var headers = {'Content-Type': 'text/plain'}
			callback(null, {
				isBase64Encoded: false,
				statusCode: 200,
				headers: setVertexSession(req, headers, opts),
				headers: headers,
				body: text
			})
		},

		redirect: function(url){
			var headers = {'Location': url}
			callback(null, {
				isBase64Encoded: false,
				statusCode: 301, // redirect stat code
				headers: setVertexSession(req, headers, opts),
				headers: headers,
				body: url
			})
		},

		render: function(template, data){
			var vertexClient = req.headers['turbo-vertex-client']
			if (vertexClient != null){
				if (vertexClient == 'widget'){
					// send back only page data rather than populated html:
					var headers = {'Content-Type': 'application/json'}
					data['pageName'] = data.pageName || template // default to template name

					callback(null, {
						isBase64Encoded: false,
						statusCode: 200,
						headers: headers,
						body: JSON.stringify(data)
					})

					return
				}
			}

			var tplData = data || {}
			const basePath = __dirname.replace('node_modules/vertex360/dist/vertex', '')
			const filePath = basePath + '/'+viewsDir+'/' + template + '.mustache'
			var partials = {}
			var template = null

			readFile(filePath)
			.then(file => {
				template = file
				return readDirectory(basePath+'/'+viewsDir+'/partials') // extract partials
			})
			.then(files => { // files from partials directory
				files.forEach(function(fileName, i){
					if (fileName.indexOf('.mustache') > -1) // mustache files only
						partials[fileName.split('.')[0]] = fs.readFileSync(basePath+'/'+viewsDir+'/partials/'+fileName, 'utf8')
				})

				return renderMustache({template:template, data:tplData, partials:partials})
			})
			.then(html => {
				var headers = {'Content-Type': 'text/html'}
				callback(null, {
					isBase64Encoded: false,
					statusCode: 200,
					headers: setVertexSession(req, headers, opts),
					body: html
				})

				return
			})
			.catch(err => {
				callback(null, {
					isBase64Encoded: false,
					statusCode: 404,
					headers: {'Content-Type': 'application/json'},
					body: JSON.stringify({
						confirmation: 'fail',
						message: err.message
					})
				})

				return
			})
		}
	}

	return res
}

const clearSession = function(){
	shouldClearSession = true
}

const bindMiddleware = function(req, res, middlewareArray){
	return new Promise((resolve, reject) => {
		if (middlewareArray==null){
			resolve({
				req: req,
				res: res
			})
			return
		}

		if (middlewareArray.length==0){
			resolve({
				req: req,
				res: res
			})
			return
		}

		let nextIndex = 0
		const callMiddlewares = function(){
			if (nextIndex < middlewareArray.length){
				const middleware = middlewareArray[nextIndex]
				middleware(req, res, () => {
					nextIndex += 1
					callMiddlewares()
				})
			}
			else {
				resolve({
					req: req,
					res: res
				})
				return
			}
		}

		callMiddlewares()
	})
}

module.exports = function(event, callback, routeParams, opts, middleware, done){ // 'opts' can be null, 'middleware' is an array
	var body = {}

	// parse POST body if founde:
	if (event.body != null){
		try { // this may come in as stringified json: "{\"name\":\"lebronjames\",\"email\":\"lebronjames@gmail.com\"}"
			body = JSON.parse(event.body)
		}
		catch(err){ // might be url-formatted: "name=dkwon&email=123" - this is how it comes back from a <form> field
			var parts = event.body.split('&')
			parts.forEach(function(keyValue, i){
				var keyValueParts = keyValue.split('=')
				if (keyValueParts.length == 2)
					body[keyValueParts[0]] = decode(keyValueParts[1])
			})
		}
	}

	var url = event.path

	var query = event.queryStringParameters || {}
	var keys = Object.keys(query)
	if (keys.length > 0){
		url += '?'
		keys.forEach(function(key, i){
			if (query[key])
				url += key+'='+query[key]
		})
	}

	var req = {
//		query: event.queryStringParameters || {},
		query: query,
		body: body,
		headers: event.headers,
		vertexSessionChanged: false,
		method: event.httpMethod.toUpperCase(),
//		url: event.path
		url: url
	}

	let cookieName = getCookieName(opts)
	var vertexSession = {reset: clearSession}
	// req['vertexSession'] = proxyVertexSession(vertexSession, req)
	req[cookieName] = proxyVertexSession(vertexSession, req)

	if (routeParams != null)
		req['params'] = routeParams.params

	// check cookies:
	var ck = event.headers['Cookie'] // "cookie": "_ga=GA1.2.1640725716.1495418605; _gid=GA1.2.1387035527.1508298483; vertexSession=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
	if (ck == null){
		const configuredResponse = configureResponse(req, callback, opts)

		bindMiddleware(req, configuredResponse, middleware)
		.then(data => {
			return done(null, {
				req: data.req,
				res: data.res
			})
		})
		.catch(err => {
			reject(err)
			return
		})

		return
	}

	// Parse cookies
	var cookies = cookie.parse(ck) // https://www.npmjs.com/package/cookie
	// if (cookies.vertexSession == null){
	if (cookies[cookieName] == null){
		const configuredResponse = configureResponse(req, callback, opts)

		bindMiddleware(req, configuredResponse, middleware)
		.then(data => {
			return done(null, {
				req: data.req,
				res: data.res
			})
		})
		.catch(err => {
			reject(err)
			return
		})

		return
	}


	// try to parse cookie:
	try {
		// const decoded = sessions.util.decode({cookieName:SESSION_COOKIE_NAME, secret:'abc'}, cookies.vertexSession)
		const decoded = sessions.util.decode({cookieName:cookieName, secret:'abc'}, cookies[cookieName])
		// looks like this: {content: "{\"user\":\"123\"}", createdAt: 1508874868373, duration: 86400000}

		if (decoded == null){ // failed, no session cookie
			const configuredResponse = configureResponse(req, callback, opts)
			bindMiddleware(req, configuredResponse, middleware)
			.then(data => {
				return done(null, {
					req: data.req,
					res: data.res
				})
			})
			.catch(err => {
				reject(err)
				return
			})

			return
		}

		if (decoded.content == null){ // failed, no session cookie
			const configuredResponse = configureResponse(req, callback, opts)
			bindMiddleware(req, configuredResponse, middleware)
			.then(data => {
				return done(null, {
					req: data.req,
					res: data.res
				})
			})
			.catch(err => {
				reject(err)
				return
			})

			return
		}

		var vertexSession = JSON.parse(decoded.content)
		vertexSession['reset'] = clearSession

		// req[SESSION_COOKIE_NAME] = proxyVertexSession(vertexSession, req)
		req[cookieName] = proxyVertexSession(vertexSession, req)
		const configuredResponse = configureResponse(req, callback, opts)

		bindMiddleware(req, configuredResponse, middleware)
		.then(data => {
			return done(null, {
				req: data.req,
				res: data.res
			})
		})
		.catch(err => {
			reject(err)
			return
		})
	}
	catch(err){
		// req[SESSION_COOKIE_NAME] = cookies.vertexSession
		req[cookieName] = cookies[cookieName]
		const configuredResponse = configureResponse(req, callback, opts)

		bindMiddleware(req, configuredResponse, middleware)
		.then(data => {
			return done(null, {
				req: data.req,
				res: data.res
			})
		})
		.catch(err => {
			reject(err)
			return
		})
	}

}
