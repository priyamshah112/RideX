const formatCallback = require('./callback')
const Router = require('./Router')
const db = require('./db')

const generateErrorCallback = (err, statusCode) => {
	return {
		isBase64Encoded: false,
		statusCode: statusCode,
		headers: {'Content-Type': 'application/json'},
		body: JSON.stringify({
			confirmation: 'fail',
			data: {
				message: err.message,
				stack: err.stack
			}
		})
	}
}

class Vertex {
	constructor(opts){ // opts can be null
		this.routes = []
		this.middleware = []
//		this.staticDir = null
		this.staticDir = 'public'
		this.opts = opts
		if (opts == null) // no config options
			return

		// Configure Options:

		this.staticDir = opts.static || 'public'

		// check if db connection required
		const dbConfiguration = opts.db // can be null
		if (dbConfiguration != null){
			if (dbConfiguration.type == null){ // default to mongo
				db.connect(dbConfiguration.url, dbConfiguration.onError, dbConfiguration.onSuccess)
			}
			else if (dbConfiguration.type == 'mongo'){
				db.connectMongo(dbConfiguration.url, dbConfiguration.onError, dbConfiguration.onSuccess)
			}
			else if (dbConfiguration.type == 'nedb'){
				db.connectNedb(dbConfiguration.url, dbConfiguration.onError, dbConfiguration.onSuccess)
			}
			else {
				db.connectMongo(dbConfiguration.url, dbConfiguration.onError, dbConfiguration.onSuccess)
			}
			// TODO: check for postgres option
			// else if (opts.db == 'postgresql')
		}
	}

	expressVersion(app){ // app is an express app
		var _this = this
		app.use('/turbo', (req, res, next) => {
			res.json({
				confirmation: 'success',
				data: JSON.stringify(_this.routes)
			})
		})

		_this.routes.forEach((route) => {
			app.use(route.stem, (req, res, next) => {
				res.json({
					confirmation: 'success',
					data: route.stem
				})
			})
		})

		return app
	}

	useStatic(directory){
		this.staticDir = directory
	}

	use(pathOrFunc, routeHandler){
		if (routeHandler == null){ // add this to middleware array
			// TODO: make sure pathOrFunc is a function, not a string
			this.middleware.push(pathOrFunc)
			return
		}

		// TODO: make sure pathOrFunc is a string, not a function,
		routeHandler.setStem(pathOrFunc)
		this.routes.push(routeHandler)
	}

	get(path, requestHandler){ // direct path, no route handler passed in:
		var routeHandler = new Router()
		routeHandler.setStem('/') // default stem to '/'
		routeHandler.get(path, requestHandler)
		this.routes.push(routeHandler)
	}

	post(path, requestHandler){ // direct path, no route handler passed in:
		var routeHandler = new Router()
		routeHandler.setStem('/') // default stem to '/'
		routeHandler.post(path, requestHandler)
		this.routes.push(routeHandler)
	}

	// TDOD: these do not exist yet on the Router.js class. Have to implement:
	// put(path, requestHandler){ // direct path, no route handler passed in:
	// 	var routeHandler = new Router()
	// 	routeHandler.setStem('/') // default stem to '/'
	// 	routeHandler.put(path, requestHandler)
	// 	this.routes.push(routeHandler)
	// }

	// delete(path, requestHandler){ // direct path, no route handler passed in:
	// 	var routeHandler = new Router()
	// 	routeHandler.setStem('/') // default stem to '/'
	// 	routeHandler.delete(path, requestHandler)
	// 	this.routes.push(routeHandler)
	// }

	routeNotFound(event, msg){
		const method = event.httpMethod.toLowerCase() // get, post, put, delete
		var data = {
			isBase64Encoded: false,
			statusCode: 501,
			headers: {'Content-Type': 'application/json'},
			body: JSON.stringify({
				confirmation: 'fail',
				message: msg
			})
		}

		return data
	}

	// this is the main entry point of the app - it is called by the actual AWS Lambda entry from the www/bin.js file:
	handle(lambda_config){ // {event: event, context: context, callback: callback}
		const event = lambda_config.event
		const callback = lambda_config.callback
		const method = event.httpMethod.toLowerCase() // get, post, put, delete

		if (method == 'post'){
			let pkg = null
			for (let i=0; i<this.routes.length; i++){
				let pathRouter = this.routes[i]
				if (pathRouter.handlePost(event) != null){
					pkg = pathRouter.handlePost(event)
					break
				}
			}

			if (pkg == null){
				callback(null, this.routeNotFound(event, method+' route not defined for this path: ' + event.path))
				return
			}

			formatCallback(event, callback, pkg.routeParams, this.opts, this.middleware, (err, formatted) => {
				if (err != null){
					callback(null, generateErrorCallback(err, 500))
					return
				}

				try {
					pkg.routeHandler(formatted.req, formatted.res)
				}
				catch(err){
					callback(null, generateErrorCallback(err, 500))
					return
				}
			})

			return
		}

		if (method == 'put'){
			let pkg = null
			for (let i=0; i<this.routes.length; i++){
				let pathRouter = this.routes[i]
				if (pathRouter.handlePut(event) != null){
					pkg = pathRouter.handlePut(event)
					break
				}
			}

			if (pkg == null){
				callback(null, this.routeNotFound(event, method+' route not defined for this path: ' + event.path))
				return
			}

			formatCallback(event, callback, pkg.routeParams, this.opts, this.middleware, (err, formatted) => {
				if (err != null){
					callback(null, generateErrorCallback(err, 500))
					return
				}

				try {
					pkg.routeHandler(formatted.req, formatted.res)
				}
				catch(err){
					callback(null, generateErrorCallback(err, 500))
					return
				}
			})

			return
		}

		if (method == 'delete'){
			let pkg = null
			for (let i=0; i<this.routes.length; i++){
				let pathRouter = this.routes[i]
				if (pathRouter.handleDelete(event) != null){
					pkg = pathRouter.handleDelete(event)
					break
				}
			}

			if (pkg == null){
				callback(null, this.routeNotFound(event, method+' route not defined for this path: ' + event.path))
				return
			}

			formatCallback(event, callback, pkg.routeParams, this.opts, this.middleware, (err, formatted) => {
				if (err != null){
					callback(null, generateErrorCallback(err, 500))
					return
				}

				try {
					pkg.routeHandler(formatted.req, formatted.res)
				}
				catch(err){
					callback(null, generateErrorCallback(err, 500))
					return
				}
			})

			return
		}

		if (method == 'get'){
			if (event.path.indexOf('.') == -1){
				let pkg = null
				for (let i=0; i<this.routes.length; i++){
					let pathRouter = this.routes[i]
					if (pathRouter.handleGet(event) != null){
						pkg = pathRouter.handleGet(event)
						break
					}
				}

				if (pkg == null){
					callback(null, this.routeNotFound(event, method+' route not defined for this path: ' + event.path))
					return
				}

				formatCallback(event, callback, pkg.routeParams, this.opts, this.middleware, (err, formatted) => {
					if (err != null){
						callback(null, generateErrorCallback(err, 500))
						return
					}

					try {
						pkg.routeHandler(formatted.req, formatted.res)
					}
					catch(err){
						callback(null, generateErrorCallback(err, 500))
						return
					}
				})

				return
			}

			// this is a static file, redirect to CDN:
			if (event.headers==undefined || event.headers==null){
				callback(null, {
					isBase64Encoded: false,
					statusCode: 500,
					headers: {'Content-Type': 'application/json'},
					body: JSON.stringify({
						confirmation: 'fail',
						data: 'Missing Turbo-Vertex-App header (headers is null)'
					})
				})

				return
			}

			const slug = event.headers['Turbo-Vertex-App']

			// USE CDN for static assets, e.g. - https://cdn.turbo360-vertex.com/dkwon-vertex-oienuk/public/images/pip.png
			const dir = this.staticDir || 'public' // default to public directory
			// const concat = 'cdn.turbo360-vertex.com/' + slug + '/' + dir + event.path
			// const url = concat.replace('//', '/') // this will happen if there is no static directory specified

			let url = null
			if (this.opts == null){ // default to Turbo CDN:
				if (slug == null){
					callback(null, {
						isBase64Encoded: false,
						statusCode: 500,
						headers: {'Content-Type': 'application/json'},
						body: JSON.stringify({
							confirmation: 'fail',
							data: 'Missing Turbo-Vertex-App header'
						})
					})

					return
				}

				const concat = 'cdn.turbo360-vertex.com/' + slug + '/' + dir + event.path
				url = concat.replace('//', '/') // this will happen if there is no static directory specified
			}
			else if (this.opts.bucket == null) { // default to Turbo CDN:
				if (slug == null){
					callback(null, {
						isBase64Encoded: false,
						statusCode: 500,
						headers: {'Content-Type': 'application/json'},
						body: JSON.stringify({
							confirmation: 'fail',
							data: 'Missing Turbo-Vertex-App header'
						})
					})

					return
				}

				const concat = 'cdn.turbo360-vertex.com/' + slug + '/' + dir + event.path
				url = concat.replace('//', '/') // this will happen if there is no static directory specified
			}
			else { // custom bucket, doesn't require Turbo-Vertex-App header
				url = 's3.amazonaws.com/' + this.opts.bucket + '/' + dir + event.path // e.g. - https://s3.amazonaws.com/turbo-demo-1/public/images/turbo.png
			}

			// redirect to CDN:
			callback(null, {
				isBase64Encoded: false,
				statusCode: 301,
				headers: {'Location': 'https://'+url},
				body: ''
			})
		}
	}
}

module.exports = Vertex
